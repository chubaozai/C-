### 1.8指针类型
#### 1.8.1 指针
    指针是一种特殊的变量，存放的是所指向对象在内存中的起始地址。在C++中，可以用指针变量来存放内存地址。
- 对于类型T，用T\*表示“指向T的指针”的类型，即 T* 类型的变量存放的是T类型的变量的地址。
- 为了赋值一个指针，就需要取出一个变量的地址，&为取地址运算符， &a 表示变量a的地址。
- 为了调用一个指针，需要取出它指向的变量的值， *为间接取值运算符， `*p表示指针p所指向的变量的值。`
```C++
char c = 'a';
char *p = &c; //p存放c的地址
char c2 = *p; //c2 = 'a'
```
对于指向数组的指针:
```C++
#include<bits/stdc++.h>
using namespace std;
int main() {
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	//可以通过数组名获取到数组首地址
	cout << "数组首地址为： " << (int)arr << endl;
	cout << "数组中第一个元素地址为： " << (int)&arr[0] << endl;
	cout << "数组中第二个元素地址为： " << (int)&arr[1] << endl;
	//arr = 100; 错误，数组名是常量，因此不可以赋值
	return 0;
}
```
对于指向函数的指针，如果函数返回值类型为 T， 参数类型为T₁，T₂，…， Tn， 那么用T( *)(T₁，T₂，…， Tn)表示指向这种函数的指针的类型。具体代码如下。
```C++
int calc(int a, int b) 
{
    return a + b;
}
int main() 
{
    int (*p) (int, int);//定义一个类型为 int(*) (int, int)的指针p,指向类型为int(int, int) 的函数
    p = calc;
    cout << p(1,2) << endl; //调用 p指向的函数
    return 0;
}
```
    声明指针时应将其赋值，否则对未赋值的指针取值会访问不确定的内存空间，从而引起未知错误。


#### 1.8.2 基于指针的数组访问

`C++中的一维数组名可以看作指向首个元素的指针，即a=&a[0]。`

若指针p指向数组a中某个元素，则p+1指向它的下一个元素，p+i指向
第i+1个元素，p-i指向它前面第i个元素。因此，如果p指向a[0]，那么p+i就指向a[i]
```C++
p+i=&a[i]
⋆(p+i) = a[i] = ⋆(a+i)。
```
    赋值p=&a[0]可以简写成p=a。
　　当数组作为函数的参数时，实际传输的是数组首个元素的地址，将数组以指针形式传输过去。

```C++
cout << "数组的元素个数为： " << sizeof(arr) / sizeof(arr[0]) << endl;
```

#### 1.8.3 字符指针
    字符指针是指向字符类型的指针，与普通指针的使用方法基本一致。
　　可以将字符串的首地址赋给字符指针，使其指向字符串。若s1为const char*型指针，可以直接用字符串字面值常量赋值，
s1="Hel1o";
合法。但若s2为字符数组,则语句 s2="Hello";不合法。

　　对于string类的str变量,可以用str. c_str()将其转化为const char* 的类型,也可以直接用 char* 和 con stchar* 的变量给其赋值。

#### 1.8.4 指向结构体的指针
指向一个结构体变量的指针，就是该变量所占据的内存段的起始地址。
　　对于一个结构体指针p，要调用其成员对象a，可以写成(\*p).a，或者更简单地写成p->a,注意不能写成*p.a。
　　当函数变量参数要传递结构体时，如果按值传递，就要复制整个结构体，效率不高，一般可以使用结构体指针。